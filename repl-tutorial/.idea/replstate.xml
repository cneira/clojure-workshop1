<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1440466013197">{:repl-history {:ide [], :local [&quot;\&quot;hu\&quot;&quot; &quot;\n(if true?  \&quot;yes\&quot;  \&quot;no\&quot; )\n&quot; &quot;(doc true? )&quot; &quot;(true? nil)&quot; &quot;(true? t)&quot; &quot;(true? true)&quot; &quot;(if (true?  nil ) \&quot;yes\&quot;  \&quot;no\&quot;  )&quot; &quot;(type true)&quot; &quot;(do \&quot;cat\&quot; \&quot;mouse\&quot; \&quot;trap\&quot; \&quot;poison\&quot;)&quot; &quot;(let [ cat \&quot;tom\&quot; mouse \&quot;jerry\&quot;  ]\n  \n    (let [ watcher \&quot;bill\&quot; ]\n      \n        (println \&quot; %s knows about %s %s\&quot; watcher  cat mouse)\n      )\n  )&quot; &quot;(let [ cat \&quot;tom\&quot; mouse \&quot;jerry\&quot;  ]\n  \n    (let [ watcher \&quot;bill\&quot; ]\n      \n        (println  watcher \&quot;knows about \&quot; cat mouse)\n      )\n  )&quot; &quot;(quote (+ 1 2))&quot; &quot;(def a \&quot;b\&quot;)&quot; &quot;(var a )&quot; &quot;(eval (var a )) &quot; &quot;(eval (var a ) ) &quot; &quot;(list 1 2 3 x t s g )\n&quot; &quot;(list 1 2 3  (quote   x t s g ) )&quot; &quot;(list 1 2 3 'x 't 's 'g )\n&quot; &quot;(defn  return-names [file]\n  (for [x (rest file ) ]\n    (let [ fields   (str/split x #\&quot;,\&quot;)]\n      (fields 1))))&quot; &quot;(return-names a)&quot; &quot;(return-person-named \&quot;Denise\&quot; a)&quot; &quot;string‚Äù&quot; &quot;\&quot;I'm a string\&quot;&quot; &quot;(type \&quot;I'm a string\&quot;)&quot; &quot;'(1 2 3 x t x s g )&quot; &quot;(list 1 2 3 'x 't 's 'g )&quot; &quot;(vector [ 1 2 3 \&quot;green\&quot; ] )&quot; &quot;(keys  { :str 13 :char 10 :dex  20 :wis 8   }  )&quot; &quot;#{:a 1 :b 2 :c 1  4}&quot; &quot;#{1 2 3 4 5 7 8 999 9}&quot; &quot;(hash-set  :a 1 :b 2 :c 1  4  )&quot; &quot;(keys (hash-set  :a 1 :b 2 :c 1  4  )) &quot; &quot;(iterate inc 0)&quot; &quot;(nth (iterate inc 0) 10000)&quot; &quot;(doc iterate)&quot; &quot;(doc inc)&quot; &quot;(doc nth\n     )&quot; &quot;(defn search-name  [file name]\n  (doseq  [x  file]\n    (let [ n ( (str/split x #\&quot;,\&quot;) 1 ) ]\n      (println n)\n      (cond\n        ( = name n ) \&quot;found your name in the list\&quot;\n         :else \&quot;Name not found\&quot;\n        ))))&quot; &quot;(search-name a \&quot;h\&quot;)&quot; &quot;(defn search-name  [file name]\n  (doseq  [x  file]\n    (let [ n ( (str/split x #\&quot;,\&quot;) 1 ) ]\n      #_(println n)\n      (cond\n        ( = name n ) \&quot;found your name in the list\&quot;\n         :else \&quot;Name not found\&quot;\n        ))))&quot; &quot;( = \&quot;Gerald\&quot; \&quot;Gerald\&quot;)&quot; &quot;(defn search-name  [file name]\n  (doseq  [x  file]\n    (let [ n ( (str/split x #\&quot;,\&quot;) 1 ) ]\n      #_(println n)\n      (cond\n        ( = name n ) (println \&quot;found your name in the list\&quot; ) \n         :else \&quot;Name not found\&quot;\n        ) )))&quot; &quot;(defn search-name  [file name]\n  (doseq  [x  file]\n    (let [ n ( (str/split x #\&quot;,\&quot;) 1 ) ]\n      #_(println n)\n      (cond\n        ( = name n ) (println \&quot;found your name in the list\&quot; )\n         :else (println \&quot;Name not found\&quot; ) \n        ) )))&quot; &quot;(search-name a \&quot;Gerald\&quot;)&quot; &quot;(defn search-name  [file name]\n  (doseq  [x  file]\n    (let [ n ( (str/split x #\&quot;,\&quot;) 1 ) ]\n      #_(println n)\n      (cond\n        ( = name n ) (println \&quot;found your name in the list\&quot; )\n         #_:else (println \&quot;Name not found\&quot; )\n        ) )))&quot; &quot;(defn search-name  [file name]\n  (doseq  [x  file]\n    (let [ n ( (str/split x #\&quot;,\&quot;) 1 ) ]\n      #_(println n)\n      (cond\n        ( = name n ) (println \&quot;found your name in the list\&quot; )\n         :else #_(println \&quot;Name not found\&quot; )\n        ) )))&quot; &quot;(search-name \&quot;Gregory\&quot;)&quot; &quot;(defn search-name  [file name]\n  (doseq  [x  file]\n    (let [ n ( (str/split x #\&quot;,\&quot;) 1 ) ]\n      #_(println n)\n      (cond\n        ( = name n ) (println \&quot;found your name in the list\&quot; )\n         :else nil #_(println \&quot;Name not found\&quot; )))))&quot; &quot;(defn search-name  [file name]\n  (doseq  [x  file]\n    (let [ n ( (str/split x #\&quot;,\&quot;) 1 ) ]\n      #_(println n)\n      (cond\n        ( = name n ) (println \&quot;I have found a \&quot; name )\n         :else nil #_(println \&quot;Name not found\&quot; )))))&quot; &quot;(defn search-name  [file name]\n  (doseq  [x  file]\n    (let [ n ( (str/split x #\&quot;,\&quot;) 1 ) ]\n      #_(println n)\n      (cond\n        ( = name n ) (println \&quot;Here is a \&quot; name \&quot;  \&quot; x )\n         :else nil #_(println \&quot;Name not found\&quot; )))))&quot; &quot;(search-name a \&quot;Gregory\&quot;)&quot; &quot;(loop [ x  a ]\n  (println x)\n  (recur (rest x ))\n  )&quot; &quot;(ns repl-tutorial.looping-conditionals\n  (:require [clojure.string :as str])\n  )&quot; &quot;(def a (str/split-lines (slurp \&quot;resources/people.txt\&quot;) ))&quot; &quot;(loop [ x  a ]\n  (println x)\n  ( if (nil? x) \&quot;end\&quot; )\n  (recur (rest x ))\n  )&quot; &quot;(loop [ x  a ]\n    (println x)\n    ( if (nil? x) \&quot;end\&quot; )\n    #_(recur (rest x ))\n    )&quot; &quot;(loop [ x  a ]\n    (println \&quot;x is \&quot; x)\n    ( if (nil? x) \&quot;end\&quot; )\n    #_(recur (rest x ))\n    )&quot; &quot;(loop [ x  a ]\n    (println \&quot;x is \&quot; x)\n    (println \&quot;res is \&quot; (rest x ))\n    ( if (nil? x) \&quot;end\&quot; )\n    #_(recur (rest x ))\n    )&quot; &quot;(loop [ x  a ]\n    #_(println \&quot;x is \&quot; x)\n    #_(println \&quot;res is \&quot; (rest x ))\n    ( if (empty?? x) \&quot;end\&quot; )\n    (recur (rest x ))\n    )&quot; &quot;a&quot; &quot;(loop [ x  a ]\n    #_(println \&quot;x is \&quot; x)\n    #_(println \&quot;res is \&quot; (rest x ))\n    ( if (empty? x) \&quot;end\&quot; )\n    (recur (rest x ))\n    )&quot; &quot;(loop [ x  a ]\n    (println \&quot;x is \&quot; x)\n    #_(println \&quot;res is \&quot; (rest x ))\n    ( if (empty? x) \&quot;end\&quot; )\n    (recur (rest x ))\n    )&quot; &quot;(empty? ())&quot; &quot;(loop [ x  a ]\n    (println \&quot;x is \&quot; x \&quot;\\n\&quot;)\n    #_(println \&quot;res is \&quot; (rest x ))\n    ( if (empty? x)  \&quot;end\&quot; \&quot;still x\&quot;)\n    (recur (rest x ))\n    )&quot; &quot;(take 1 a)&quot; &quot;(take 2 a)&quot; &quot;(next a)&quot; &quot;( =  (next a)  (rest a )) &quot; &quot;( - 2 1)&quot; &quot;(next a 1001)&quot; &quot;(count a)&quot; &quot;(doc rest )&quot; &quot;(loop [ x  a ]\n    (println \&quot;x is \&quot; x \&quot;\\n\&quot;)\n    #_(println \&quot;res is \&quot; (rest x ))\n    ( if (nil? x)  \&quot;end\&quot; \&quot;still x\&quot;)\n    (recur (next x ))\n    )&quot; &quot;(loop [ x  a ]\n    #_(println \&quot;x is \&quot; x \&quot;\\n\&quot;)\n    #_(println \&quot;res is \&quot; (rest x ))\n    ( if (nil? x)  \&quot;end\&quot; \&quot;still x\&quot;)\n    (recur (next x ))\n    )&quot; &quot;(loop [ x 10]\n  (println x )\n  (recur ( - x 2)))&quot;], :remote []}}</component>
</project>